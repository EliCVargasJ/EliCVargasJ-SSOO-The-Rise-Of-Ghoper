Estructura de la paginacion multinivel jerarquica del tp: 


Ejemplo de como funcionaria: 

Tenemos:
 pagina 6 -> ruta: [1][3][1] // Existe la direccion
 pagina 7 -> ruta: [1][3][2] // No existe la direccion

 Para la estructura de la pagina 6 seria algo asi: 

Raíz (nivel 0)
 └── entrada[1] → subtabla (nivel 1)
       └── entrada[3] → subtabla (nivel 2)
             └── entrada[1] = frameID

  [1] → subtabla (apuntada desde el nivel 0)
  [3] → subtabla (apuntada desde el nivel 1)
  [1] = frameX   (apuntada desde el nivel 2)

lo podemos ver asi: Nivel 0 → [1], Nivel 1 → [3], Nivel 2 → [1] -> frameID

pero para la pagina 7 tenemos: 

Raíz (nivel 0)
 └── entrada[1] → subtabla (nivel 1)
       └── entrada[2] → subtabla (nivel 2)
             └── entrada[2] = (no asignada / nil / página no existe)


[1] -> (apuntada desde el nivel 0)
[3] -> (apuntada desde el nivel 1)
[2] -> (apuntada desde el nivel 2) -> No Existe, entonces completo con el nuevo frame.  

lo podemos ver asi : Nivel 0 → [1], Nivel 1 → [3], Nivel 2 → [2] -> nil

Al momento de asignar el nuevo frame implementamos la logica de "hayEspacio" 

---------------------- Para Kernel ---------------------------

1. Calculo la cantidad de paginas segun lo que pida Kernel
2. Por cada pagina logica tengo que: 
  * Generar los indices de tabla ( nivel=, nivel1, ..., nivel5)
  * Busco por la jerarquia la ubicacion: 
     - Si una tabla hija no existe, la creo 
     - si es el ultimo nivel, reservo un frame fisico libre y le doy el lugar a Kernel. 


---------------------- Para CPU -------------------------------------


Creo el proceso -> genero su tabla raiz y jerarquia de tablas y  reservo los frames.
Leer o escribir -> busco en la jerarquia de paginas para traducir la direccion logica a fisica
Suspender proceso -> guardo su estructura en un archivo SWAP, importante NO elimino sus tablas, las va necesitar cuando vuelva a Ready.
Termino el proceso -> Libero los frames y elimino sus tablas. 

Trabajo con CPU: 

CPU me va dar el PID, la DIRECCION LOGICA y el SIZE cada vez que necesite leer/escribir. 
En la jerarquia de tablas de proceso (rootTables[PID]), busco en los niveles usando los indices. 
Cuando llego al final voy a obtener el frameID y accedo a memoria con memoria[frameID*tamanioPagina + offset]

// Falta pensar el tema de swap 

------------------------ Funciones necesarias generales -----------------------

TYPE ASSERTION: como usamos una variable interface {} (o sea, tipo cualquiera) no sabemos que hay adentro, entonces cuando 
la usemos tenemos que verificar que lo que nos devuelve es del tipo de dato que necesitamos. 

lo hacemos con un if: 

 if tabla.Entradas[indice] == [dato que necesito ] 
 {
    blablablablablabla
 }
else {
    Logger.Info(fmt.Sprintf("Error"))
}

----------------------------------- SWAP -------------------------------------------------

------------------------------------Checkpoint 3 -----------------------------------------
 
Leer config (memory_size, page_size, etc.)	                   (listo)
Iniciar memoria principal ([]byte)	                           (listo)
Crear y gestionar bitmap de frames	                           (listo)
Crear tablas multinivel por proceso	                           (listo)
Traducir dirección lógica → física	                           (listo, creo, hay que preguntar bien en soporte)
Atender INIT_PROC, SUSPEND, EXIT del Kernel	                   (falta)
Atender LEER y ESCRIBIR de CPU	                               (listo)
Exponer endpoints HTTP para todas las funciones	               (listo)
Logs obligatorios                                              (listo)           
Simulación básica de swap (puede ser memoria o archivo)        (falta)
memoria_dump (pedido desde Kernel)                             (listo)    

----------------------------------------Leer en memoria ----------------------------------------

1. Validar que el proceso y la dirección existen.
2. Leer el valor almacenado en la memoria 


---------------------------------------- Dump Memory --------------------------------------------

Entiendo por dump memory el tener que poner en disco todo el estado completo de un proceso, esto va pasar cuando Kernel 
nos diga que hagamos un dump memory del proceso con PID XXX, 
* debemos devolver a Kernel la confirmacion de la finalizacion del dump memory

Lo que entiendo que tiene que hacer la funcion: 

1. recibe la peticion de dump desde Kernel con el PID del proceso a hacer dump
2. Verifico que el PID existe y que el proceso esta en estado READY o BLOCKED
3. Creo un archivo con el nombre del PID (ej: 0001-1500.dmp)
 ** nota sobre 0001-1500.dmp, 0001 corresponde al PID y 1500 corresponde al timestamp de cuando se hizo el dump, suponemos que es el memory_delay
4. Debo poner el archivo en la carpeta "/home/utnso/dump_files/"
5. cierro el archivo y le mando el OK a Kernel 

Nota importante: 
En el archivvo que mando a dump, debo tener: 
- todo lo que el proceso tiene en memoria PRINCIPAL, no lo que tiene en SWAP, todo tiene que estar escrito asi como esta, en binario. 

Por ejemplo. si el proceso tiene en memoria principal: 

pagina                                     Contenido 
  0    -> En memoria        marco 2          "Hola"
  1    -> En SWAP 
  2    -> En memoria        marco 7          "Mundo"

y su page_size es de 5, entonces el archivo que genero tiene que tener:
0001-1500.dmp 
bytes 0-4: "Hola"
bytes 5-9: 0000
bytes 10-14: "Mundo"



-------------------------------------------------------------------------------------------
//espacio para Juanjo-Eli, comentarios sobre cosas que modificamos individualmente

----------------------- Comentarios de Juanjo --------------------------------

----------------------- Comentarios de Eli --------------------------------

** Tuve que crear una variable global llamada TamanioProceso, que es la cantidad de paginas que tiene el proceso, no estoy segura 
si es necesario, pero me estaba complicando con el dump memory, entonces crearla me resolvia el problema. 
Chequeamos despues si es necesaria o si en algun lugar la habiamos calculado o algo por el estilo.
La funcion esta creada en globals.go, despues tuve que guardar el tamanio de paginas del proceso cuando lo creaba en la funcion PidenEspacioHandler (a chequear si esto esta bien, lo dudo)
y recien ahi despues usarla en la funcion DumpMemoryHandler.